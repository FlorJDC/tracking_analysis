# -*- coding: utf-8 -*-
"""
Created on Wed Nov 13 17:33:49 2024

Author: Lucía Lopez
Florencia D. Choque 
Description:
This script processes experimental pMINFLUX data using fitted point spread functions (PSFs) and TCSPC data.
At this stage, the MINFLUX excitation pattern has already been aligned, and the distances between the minima of the pattern 
have been confirmed to be good enough after a fitting process. 
This alignment and quality check are performed using `analise_EBP`, which operates on the raw PSFs generated by the MINFLUX setup.

Recommendations:
- Verify the τ parameter values, as they correspond to the peaks in the relative time histogram. 
Any hardware changes, such as swapping cables, may alter these values, potentially introducing errors. 
Future versions should automate this calibration to enhance robustness.

Details:
- An offset is applied to the relative time histogram peaks to match the acquisition order of the setup's PSFs.
- The `lifetime_win_i` and `lifetime_win_f` parameters specify the time window used for photon counting.

Note:
This code still requires adaptation for tracking experiments using Swabian hardware. But so far this is our working version.

"""

import os
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
import tools_pMINFLUX as tools

# Parameters
ABS_TIME_CONVERSION = 1e-3
K, step_nm = 4, 1
background_rate, tcspc_binning = 15600, 0.005 #[Hz],[s]
lifetime_win_i, lifetime_win_f = 0, 5

# Open fitted experimental PSFs
psf_dir = 'C:\\Users\\Cibion\\Pictures\\Data\\20241122\\psf_20241122_1_Resultados\\fit' #Fitted images

psf_fit, pos_min = [], []

for fname in os.listdir(psf_dir):
    if fname.lower().endswith((".tiff", ".tif")):
        img = np.array(Image.open(os.path.join(psf_dir, fname)))
        psf_fit.append(img)
        size = np.shape(img)[1]
        size_nm = size * step_nm
        min_idx = np.unravel_index(np.argmin(img), img.shape)  # Convert to 2D index
        pos_min.append(tools.indexToSpace(min_idx, size_nm, step_nm))

psf_fit, pos_min = np.array(psf_fit), np.array(pos_min)

colors = ['blue', 'orange', 'gray', 'yellow']


# Plot PSFs
fig, axes = plt.subplots(2, 2, figsize=(8, 8))
for i, ax in enumerate(axes.flat):
    ax.set(xlabel = 'x (nm)', ylabel= 'y (nm)')
    ax.imshow(psf_fit[i], cmap='viridis')
    ax.scatter(*np.unravel_index(np.argmin(psf_fit[i]), psf_fit[i].shape)[::-1], 
                color=colors[i], s=100)
    ax.set_title(f'Fitted PSF {i}', fontsize=10)
plt.tight_layout()

# Load TCSPC Data
#tcspc_file = r'\\192.168.114.21\na\Florencia Choque\Data\20241122\Medicion_cuadrado_3\filename_arrays.txt'
tcspc_file = r'C:\Users\Cibion\Pictures\Data\20241122\Medicion_cuadrado_3\filename_arrays.txt'

rel_time, abs_time = np.loadtxt(tcspc_file, unpack=True)
abs_time *= ABS_TIME_CONVERSION
rel_time_new = (rel_time + 17) % 50

# τ values and histogram
τ = np.array([0.2, 13.2, 25.5, 38.7]) # peak positions [ns]
plt.figure('Histogram_rel_time')
plt.hist([rel_time, rel_time_new], bins=300, label=['rel_time', 'rel_time_new'], alpha=0.7)
for tau in τ:
    plt.axvline(tau, color='red', linestyle='--')
    plt.axvspan(tau + lifetime_win_i, tau + lifetime_win_f, color='red', alpha=0.2)
plt.xlabel('Time [ns]'), plt.ylabel('Counts'), plt.legend(), plt.tight_layout()

# Estimate Positions
nbins, bin_size = int(np.max(abs_time) / tcspc_binning), len(rel_time_new) // int(np.max(abs_time) / tcspc_binning)
r0_est_nm, N, SBR = np.zeros((2, nbins)), np.zeros(nbins), np.zeros(nbins)

for i in range(nbins):
    window = rel_time_new[i * bin_size:(i + 1) * bin_size]
    SBR[i] = len(window) / (tcspc_binning * background_rate)
    n_array = tools.n_minflux(τ, window, lifetime_win_i, lifetime_win_f)
    _, r0_est_nm[:, i], _ = tools.pos_minflux(n_array, psf_fit, SBR[i], step_nm) #Already in nm, check pos_minflux
    N[i] = np.sum(n_array)

# Scatter Plot with Estimated Positions
x_loc, y_loc = r0_est_nm[0] - pos_min[2][0], r0_est_nm[1] - pos_min[2][1]
meanx, meany = np.mean(x_loc), np.mean(y_loc)
sigmax, sigmay = np.std(x_loc), np.std(y_loc)

plt.figure('Localizations')
for i, p in enumerate(pos_min):
    plt.scatter(*(p - pos_min[2]), color=colors[i], s=100)
plt.scatter(x_loc, y_loc, c='gray', s=20, alpha=0.25)
plt.scatter(np.mean(x_loc), np.mean(y_loc), color='black', marker='+')
# Annotations
plt.annotate(f'<x> = {meanx:.2f} nm', xy=(0.05, 0.80), xycoords='axes fraction', fontsize=8, color='blue', verticalalignment='top')
plt.annotate(f'<y> = {meany:.2f} nm', xy=(0.05, 0.75), xycoords='axes fraction', fontsize=8, color='blue', verticalalignment='top')
plt.annotate(f'σx = {sigmax:.2f} nm', xy=(0.05, 0.95), xycoords='axes fraction', fontsize=8, color='blue', verticalalignment='top')
plt.annotate(f'σy = {sigmay:.2f} nm', xy=(0.05, 0.90), xycoords='axes fraction', fontsize=8, color='blue', verticalalignment='top')
plt.gca().set_aspect('equal'), plt.xlabel('x (nm)'), plt.ylabel('y (nm)'), plt.tight_layout()

# Scatter Plot with Time Encoding
plt.figure('Localizations_time_encoding')
for i, p in enumerate(pos_min):
    plt.scatter(*(p - pos_min[2]), color=colors[i], s=100)
plt.scatter(x_loc, y_loc, c=range(len(x_loc)), cmap='rainbow', s=20)
plt.gca().set_aspect('equal'), plt.colorbar(label='Time encoding')
plt.xlabel('x (nm)'), plt.ylabel('y (nm)'), plt.tight_layout()

# Get the current axes limits from the scatter plot (we want to match these for CRB plot)
ax = plt.gca()
ax.get_xlim()
ax.get_ylim()

#%% CRB Calculation and Plot
σ_CRB = tools.crb_minflux(K, psf_fit, np.mean(SBR), step_nm, size_nm, np.mean(N), method='1')

# Create the CRB plot with the same extent as the scatter plots
plt.figure('CRB_map')
plt.imshow(σ_CRB, cmap='viridis', vmin=0, vmax=20)
plt.colorbar(label='σ_CRB Value')

# Plot PSF minima positions with the same color mapping as before
for i, p in enumerate(pos_min):
    plt.scatter(*np.unravel_index(np.argmin(psf_fit[i]), psf_fit[i].shape)[::-1], 
                color=colors[i], s=100)

# Ensure the axes and aspect ratio are the same as in scatter plots
plt.gca().set_aspect('equal')
plt.xlabel('x (nm)')
plt.ylabel('y (nm)')
plt.title('σ_CRB with Aligned Reference Frame')
plt.tight_layout()
plt.show()